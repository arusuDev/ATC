# 13日目(2019/8/27)
## AtCoder Beginner Contest 030
<!-- 何かあればここに書く -->
## 解けた問題
### A:勝率計算
<!-- 解説・感想 -->
double型でA~Dを受け取って、  
``` B/A > D/C ```  
の結果によって分岐させるだけー。
### B:時計盤
はじめなんか難しく考えちゃったけど、とりあえず長針から考えることにする。  
長針は60分で一周するので、一回の角度は`360/60 = 6`度になります。   
これで長針の角度は12時を0として考えると`6*m`で求まる。  
次に短針。まず与えられる数値から大雑把な位置を考えると、  
12時間で一周するので、1時間あたり`360/12 = 30`度になります。24時間で与えれるけど、12時間後の数は変わらないので、ざっくりした位置(長針が0の時の位置)は、`30*(n%12)`でもとまります。  
これに加えて、長針が進むと30度の間を徐々に進んでいくので、この30度を60分割してあげたものに`m`を掛けたものを足してあげればいい。  
-> `30*(n%12) + 0.5*m`
あとは差分をとってあげればいいですね。差分が180度超えてたら360から引いてあげれば角度の小さい方が取れるはず！ 
あんまりきれいじゃないソース  
```cpp
    int n,m;
    cin >> n >> m;
    double n_dir,m_dir;
    m_dir = m*6;
    n_dir = (n%12)*30 + m*0.5;
    if(m_dir > n_dir)
        if(m_dir-n_dir > 180){
            cout << 360 - m_dir + n_dir << endl;
        }else{
            cout << m_dir - n_dir << endl;
        }
    else if(m_dir < n_dir)
        if(n_dir-m_dir > 180){
            cout << 360 - n_dir + m_dir << endl;
        }else{
            cout << n_dir - m_dir << endl;
        }
    else
        cout << 0 << endl;  
```
### C:飛行機乗り  
正直実装しながら部分解だろうなって思いながら実装してたけどACできました。  
aとbを往復できる回数を考える問題。a->bにはX時間 b->aにはY時間かかる。
出発時刻はaはN個 bはM個与えられる。  
  
考え方として、往復できる回数をカウントする`count`,現在時刻を保存する`time`,そして出発時刻のindexをそれぞれ保存するための変数`a_idx`,`b_idx`を定義。  
whileでループを回して、a_idxかb_idxが配列サイズを超えたらそれ以上の出発時刻はない（飛行機が終わってる）ので終了。  
どの飛行機に乗っても固定の時間で移動できるってことは、いま現状で最速の飛行機に乗ればいいよねっていう考えだからもしかしてこれは前に学んだ貪欲法ってやつなのかな？  
```cpp
time = (今現在で最速の出発時間) + (移動時間) 
```
で更新してゆく。b->aの移動が終わったタイミングで`count`変数をインクリメントして最後に出力。

```cpp
    int count = 0,time=a[0],a_idx=0,b_idx=0;
    //a[0]から飛ぶとすると、bにつくのは、a[0]+X
    while(a_idx<N && b_idx<M){
        //a[0]に乗るところから始まる。
        time = a[a_idx] + X;
        while(b[b_idx] < time && b_idx<M){
            //bの時刻が時間よりも小さいならば乗れないので飛ばす。
            b_idx++;
        }
        if(b_idx == M){
            break;
        }
        //bからaに移動するにはY時間かかる。
        time = b[b_idx] + Y;
        count++;
        while(a[a_idx] < time&& a_idx<N){
            a_idx++;
        }
        if(a_idx == N){
            break;
        }
    }
    cout << count << endl;
```
## 解けなかった問題
### D:へんてこ辞書  
きょうはあまり時間取れなかったので35分くらいで切り上げました。  
問題を見る限りiterationがめちゃくちゃ多いから、これをすると現実的な時間で終わらせられなくなる。なので、ループになる部分をうまく検出して、そのループする単語の並びから剰余を求めて答えを出すんだと思うんだけど…  
実装力が足りない。
## 解説を見てみる
### A
ACはしたけど、少数比較だと浮動小数点の誤差に左右されるかもしれないので、微小な数epsilonを準備して実装するか、両辺にA*Cを掛けて大小比較するのが安心。  
なるほどですねー
### C
配列から今の時刻以上の最小の値を探せば良いっていう考えは一緒で、->std::lower_boundという関数があるらしいからそれを使えばいいみたい。
### D
考え方としてはあってるみたい。グラフとして捉えると、ループする閉路と、その閉路にたどり着くための木の部分で構成されている。  
支点aからk mod C回動けば答えが求まる。
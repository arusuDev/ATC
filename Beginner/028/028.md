# 11日目(2019/8/25)
## AtCoder Beginner Contest 028
昨日問題に取り組めなかったので連続記録が途切れてしまって悲しいけど、ここでやめてしまったら習慣じゃなくなっちゃうので気を取り直して、続きからやります。  
今日はBeginner Contest 028でした。50分ほど問題に取り組んで予定外にDまでACできた！やった～
<!-- 何かあればここに書く -->
## 解けた問題 
### A:テスト評価
Nを受け取ってif文で分岐しました。それだけ！
<!-- 解説・感想 -->
### B:文字数カウント
`int`型の配列を要素数6,0で初期化して定義。
`string`型のSを受け取って、文字列の長さでループ。
S[i]が指し示すものは`char`型なので、A~Fしか問題に出てこないので、`A`を引いてあげることでASCIIコードの引き算ができてその文字が`A`から数えて何文字目か分かる。  
これを利用して次のように実装しました。
```cpp:
    int s[6] = {0,0,0,0,0,0};
    cin >> S;
    for(int i=0;i<S.size();i++){
        s[S[i]-'A']++;
    }
    for(int i=0;i<5;i++){
        cout << s[i] << " "; 
    }
    cout << s[5] << endl;
```

### C:数を3つ選ぶマン
良い実装方法を思いつかなかったから問題文そのまま実装しました。3重ループを書きました。1~3番目の暫定解を保存して、1~3番目の値より大きい入力が来たら更新を行う。数の大きい順に合計値を求めていき、1~3番目の要素より結果が小さくなったらそれより下の数を足しても暫定解の更新はないので`break`しました。
```cpp:
    int n[5];
    int one=0,two=0,three=0;
    for(int i=0;i<5;i++)
        cin >> n[i];
    for(int i=4;i>=2;i--){
        for(int j=i-1;j>=1;j--){
            for(int k=j-1;k>=0;k--){
                if(one < n[i]+n[j]+n[k]){
                    three = two;
                    two = one;
                    one = n[i]+n[j]+n[k];
                }else if(two < n[i]+n[j]+n[k]){
                    three = two;
                    two = n[i]+n[j]+n[k];
                }else if(three < n[i]+n[j]+n[k]){
                    three = n[i]+n[j]+n[k];
                }else{
                    break;
                }
            }
        }
    }
    cout << three << endl;
```
もっとスマートな実装方法流石にありそう…。
### D:乱数生成
3回N以下の数で乱数を生成し、中央値がKになる確率を求める問題。中央値がKになるということは、K以上の数・K・K以下の数が出るときの確率を考えればいいとまず考えました。  
K以上の数が出る確率をKp、Kが出る確率をK,K以下の数が出る確率をKmとすると、Kp,K,Kmの時を求めれば良い。しかし、このままだとKpでKが出た時、KmでKが出たときの処理を考えるのが面倒だったので、Kより大きい数とKより小さい数を考えることにしました。  
そうすると、条件を満たすパターンは、(K,K,K)、(Kp,K,K),(K,K,Km)、そして(Kp,K,Km)の時になります。順列を考えると、  
| 組み合わせ     | 順列P |
| --------- | --- |
| (K,K,K)   | 1   |
| (Kp,K,K)  | 3   |
| (K,K,Km)  | 3   |
| (Kp,K,Km) | 6    |
となるので、それぞれの確率に順列を掛けたものを足してあげると答えが出ます。  

```cpp:
int main(void){
    int N,K;
    cin >> N >> K;
    //(K以下,K,K以上)の組み合わせが出るパターンを考えればいいはず。
    // Kが出る確率は、1/Nの確率。Kよりおおきい数が出る確率は、N-K/N,K未満が出る確率はK-1/Nである。
    double K_p = 1/double(N);
    double Km_p = (K-1)/double(N);
    double Kp_p = (N-K)/double(N);
    cout << setprecision(10) << (K_p * Kp_p * Km_p*6 + K_p * K_p * K_p + K_p * K_p * Km_p*3 + Kp_p*K_p*K_p * 3) << endl;
}
```
## 解けなかった問題
初めて全部解けた…！
## 解説を見てみる
### C:3つ選ぶマン
A B C D E  
の5つの数がある中で作成できる数の中で一番大きいものは
C D E  
である。
2番目に大きいものは
B D E  
である。
3番目に大きいのは、
A D E か B C E になる。  
これに気づくとmax(A D E,B C E);を出力すればいい！  
これはめっちゃ短くなりますね…。

### D:乱数生成
Kが何回出力されたかで考えるらしい。  
アプローチの仕方は解いた方法と一緒かな。